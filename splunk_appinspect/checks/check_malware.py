# Copyright 2018 Splunk Inc. All rights reserved.

"""
### Malware, viruses, malicious content, user security standards
"""

# Python Standard Libraries
import logging
import os.path
import re
import subprocess
import sys
import platform
import ipaddress
# Third-Party Libraries
# N/A
# Custom Libraries
import splunk_appinspect

logger = logging.getLogger(__name__)
report_display_order = 5


@splunk_appinspect.tags('splunk_appinspect', 'offensive', 'manual')
@splunk_appinspect.cert_version(min='1.0.0')
def check_for_offensive_material(app, reporter):
    """Check that the app does not include any offensive material."""
    if platform.system() == "Windows":
        reporter.manual_check("Offensive language checks will be done manually during code review.")
    else:
        # False positives? False negatives?  You betcha. But it's a start. (And
        # that's why we warn either way.)
        likely_offensive_files = []
        for dir, filename, ext in app.iterate_files():
            file_path = os.path.join(dir, filename)
            for lineno, line, found, suspected in splunk_appinspect.offense.scan_file(app.get_filename(dir, filename)):
                formatted = line.replace(found, '<<<' + found.upper() + '>>>')
                if len(formatted) > 65:
                    formatted = formatted[:65] + '...'
                reporter.manual_check("{} ({}:{}) [{}]. File: {}, Line: {}.".format(
                    formatted, file_path, lineno, found, file_path, lineno), file_path, lineno)


@splunk_appinspect.tags('splunk_appinspect', 'manual')
@splunk_appinspect.cert_version(min='1.0.0')
def check_embedded_links(app, reporter):
    """Check that embedded links included in the app are not malicious."""
    reporter.manual_check("Links will be manually inspected during code review.")


@splunk_appinspect.tags('splunk_appinspect', 'manual')
@splunk_appinspect.cert_version(min='1.0.0')
def check_authorization_credentials(app, reporter):
    """Check that no plain text authorization credentials are stored in the
    app.
    """
    reporter.manual_check("Code will be manually inspected during code review.")


@splunk_appinspect.tags('splunk_appinspect', 'cloud')
@splunk_appinspect.cert_version(min='1.0.0')
def check_hostnames_and_ips(app, reporter):
    """Check that no sensitive hostnames/IPs are stored in the app."""

    PUBLIC_DNS_LIST = [
                        '208.67.222.222', '208.67.220.220', # OpenDNS 
                        '1.1.1.1', '1.0.0.1', # Cloudflare
                        '8.8.8.8', '8.8.4.4', # Google Public DNS
                        '199.85.126.10', '199.85.127.10', # Norton ConnectSafe
                        '8.26.56.26', '8.20.247.20', # Comodo Secure DNS
                        '9.9.9.9', '149.112.112.112' # Quad9
                    ]
    SAFE_PRIVATE_IP_LIST = ['0.0.0.0', '127.0.0.1', '255.255.255.255']
    
    results = app.search_for_pattern('(^|[^\\d\\w\\.])(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})(?!/[1-3]?\\d($|[^\\d\\w\\.]))($|[^\\d\\w\\.])')

    distinct_ip = {}
    for result in results:
        ip = result[1].groups()[1]
        address = None
        try:
            address = ipaddress.ip_address(unicode(ip))
        except Exception, ex:
            pass

        if address:
            filename, lineno = result[0].split(':')
            if address.is_loopback:
                continue
            if ip in SAFE_PRIVATE_IP_LIST or ip in PUBLIC_DNS_LIST:
                continue
            if re.search('((requests|botocore|boto)/utils|scopes|socks|ipv4|dns/(query|resolver)|ipaddr|backports/socket|ipaddress(/__init__)?|ip/__init__)\\.py', filename):
                continue

            
            if distinct_ip.get(filename) == None:
                distinct_ip[filename] = set()

            if ip in distinct_ip[filename]:
                continue
            if len(distinct_ip[filename]) == 100:
                continue

            if address.is_global:
                ip_type = 'PUBLIC'
            elif address.is_private:
                ip_type = 'PRIVATE'
            elif address.is_reserved:
                ip_type = 'RESERVED'
            elif address.is_multicast:
                ip_type = 'MULTICASE'
            elif address.is_unspecified:
                ip_type = 'UNSPECIFIED'
            else:
                ip_type = 'UNKNOWN' 

            distinct_ip[filename].add(ip)
            report = '{} IP {} is found in {}:{}'.format(ip_type, ip, filename, lineno)
            reporter.warn(report, filename, lineno)

